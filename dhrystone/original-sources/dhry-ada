# to unbundle, sh this file (in an empty directory)
echo d_global.s 1>&2
sed >d_global.s <<'//GO.SYSIN DD d_global.s' 's/^-//'
-------------------------------------------------------------------------
---
---                   "DHRYSTONE" Benchmark Program
---                   -----------------------------
---                                                                            
---  Version:    Ada, Version 2.1
---                                                                            
---  File:       d_global.s (part 1 of 6)
---
---  Date:       December 17, 1988
---
---  Author:     Reinhold P. Weicker
---                      Siemens AG, AUT E 51
---                      Postfach 3220
---                      8520 Erlangen
---                      Germany (West)
---                              Phone:  [+49]-9131-7-20330
---                                      (8-17 Central European Time)
---                              Usenet: ..!mcsun!unido!estevax!weicker
---
---              Original Version published in "Communications of the ACM"
---		vol. 27., no. 10 (Oct. 1984), pp. 1013 - 1030,
---              together with the statistics on which the distribution
---		of statements etc. is based.
---
---              In this Ada version, the predefined package TEXT_IO
---		is used for Input/Output. For portability, only
---		Standard Ada language features are used for time
---		measaurement. This means that the procedure "Clock" of
---		package CALENDAR is used to measure the time,
---		even though it returns the elapsed time and not the CPU time.
---		See comments in d_pack_1.b for a discussion of
---		time measurement methods.
---
---  Collection of Results:
---              Reinhold Weicker (address see above) and
---              
---              Rick Richardson
---              PC Research. Inc.
---              94 Apple Orchard Drive
---              Tinton Falls, NJ 07724
---                      Phone:  (201) 389-8963 (9-17 EST)               
---                      Usenet: ...!uunet!pcrat!rick
---
---      Please send results to Reinhold Weicker and Rick Richardson.
---      Complete information should be given on hardware and software used.
---      Hardware information includes: Machine type, CPU, type and size
---      of caches; for microprocessors: clock frequency, memory speed
---      (number of wait states).
---      Software information includes: Compiler (and runtime library)
---      manufacturer and version, compilation switches, OS version.
---      The Operating System version may give an indication about the
---      compiler; Dhrystone itself performs no OS calls in the measurement loop.
---
---      The complete output generated by the program should be mailed
---      such that at least some checks for correctness can be made.
---
-------------------------------------------------------------------------
---
---  History:    This version Ada/2.1 has been made for two reasons:
---
---              1) As far as it is possible without changes to the Dhrystone
---              statistics, optimizing compilers should be prevented from
---              removing significant statements.
---
---              2) With the new (2.1) C and Pascal versions, there should
---		be a corresponding Ada version. Also, the Ada version of
---		Dhrystone has not yet found a network distribution comparable
---		to the C version (version 1.1) distributed by Rick Richardson.
---             
---              This Ada version 2.1 has been made consistent with the
---              C version 2.1; therefore the acknowledgments for the C version
---              are due for the Ada version as well: I thank
---              Rick Richardson (Tinton Falls, NJ), Chaim Benedelac (Nat.
---              Semi.), David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
---              Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
---              for their help with comments on earlier versions of the
---              benchmark.
---
---  Changes:    In the initialization part, this version follows mostly
---              Rick Richardson's C version distributed via Usenet, not the
---              version distributed earlier via floppy disk by Reinhold Weicker.
---              Inside the measurement loop, this version follows the
---              version previously distributed by Reinhold Weicker.
---
---              At several places in the benchmark, code has been added,
---              but within the measurement loop only in branches that 
---              are not executed. The intention is that optimizing compilers
---              should be prevented from moving code out of the measurement
---              loop, or from removing code altogether. Since the statements
---              that are executed within the measurement loop have NOT been
---              changed, the numbers defining the "Dhrystone distribution"
---              (distribution of statements, operand types and locality)
---              still hold. Except for sophisticated optimizing compilers,
---              execution times for this version should be the same as
---              for previous versions.
---              
---		Since it has proven difficult to subtract the time for the
---		measurement loop overhead in a correct way, the loop check
---		has been made a part of the benchmark. This does have
---		an impact - though a very minor one - on the distribution
---		statistics which have been updated for this version.
---
---              All changes within the measurement loop are described
---              and discussed in the companion paper "Rationale for
---              Dhrystone version 2".
---
---              Because of the self-imposed limitation that the order and
---              distribution of the executed statements should not be
---              changed, there are still cases where optimizing compilers
---              may not generate code for some statements. To a certain
---              degree, this is unavoidable for small synthetic benchmarks.
---              Users of the benchmark are advised to check code listings
---              whether code is generated for all statements of Dhrystone.
---
-------------------------------------------------------------------------
---
---  Compilation model and measurement (IMPORTANT):
---
---  This Ada version of Dhrystone consists of six files
---  (file names shortened to 8 characters for MS-DOS floppy disk distribution):
---
---  - d_global.s (this file, containing global definitions and comments)
---  - d_pack_1.s (containing the package specification of Pack_1)
---  - d_pack_2.s (containing the package specification of Pack_2)
---  - d_pack_1.b (containing the package body of Pack_1)
---  - d_pack_2.b (containing the package body of Pack_2)
---  - d_main.b (containing procedure "main", very short)
---
---  The following "ground rules" apply for measurements:
---  - Separate compilation
---  - No procedure merging
---  - Otherwise, compiler optimizations are allowed but should be indicated
---  - Default results are those without register declarations
---  See the companion paper "Rationale for Dhrystone Version 2" for a more
---  detailed discussion of these ground rules.
---
---  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
---  models ("small", "medium", "large" etc.) should be given if possible,
---  together with a definition of these models for the compiler system used.
---
---------------------------------------------------------------------------------
---
---  [Comment from the first distribution, still valid in principle.
---   Note that because of the inclusion of the measurement loop iteration,
---   the numbers are slightly different from the published version.]
---
---  The following program contains statements of a high level programming
---  language (here: Ada) in a distribution considered representative:
---
---    assignments                  53 %
---    control statements           32 %
---    procedure, function calls    15 %
---
---  100 statements are dynamically executed. The program is balanced with
---  respect to the three aspects:
---
---    - statement type
---    - operand type (for simple data types)
---    - operand access
---         operand global, local, parameter, or constant.
---
---  The combination of these three aspects is balanced only approximately.
---
---  1. Statement Type:
---  -----------------             number
---
---     V1 := V2                   10
---     V := Constant              12
---       (incl. V1 := F(
---     Assignment,                 7
---       with array element
---     Assignment,                 6
---       with record component
---                                --
---                                35       35
---
---     X := Y +|-|and|or Z         5
---     X := Y +|-|"=" Constant     6
---     X := X +|- 1                3
---     X := Y *|/ Z                2
---     X := Expression,            1
---          two operators
---     X := Expression,            1
---          three operators
---                                --
---                                18       18
---
---     if .... then ....          14
---       with "else"      7
---       without "else"   7
---           executed        3
---           not executed    4
---     for  ...  loop              7  |  counted every time
---     while ... loop              4  |  the loop condition
---     loop .... exit              1  |  is evaluated
---     case ... end case           1
---     return                      5
---     rename                      1
---                                --
---                                33       33
---
---     P (...)  proced. call      10
---       same package        5
---       other package       5
---
---     X := F (
---          function  call         5
---       same package        2
---       other package       3
---                                --
---                                15       15
---                                        ---
---                                        101
---
---    22 of the 58 assignments have a variable of a constrained
---    (sub-)type as their destination. In general, discriminant checks
---    will be necessary in these cases; however, the compiler may
---    optimize out some of these checks.
---
---    The average number of parameters in procedure or function calls
---    is 1.80 (not counting the function values as implicit parameters)
---
---
---  2. Operators
---  ------------
---                          number    approximate
---                                    percentage
---
---    Arithmetic             27          52.9
---
---       +                     16          31.4
---       -                      7          13.7
---       *                      3           5.9
---       /                      1           2.0
---
---    Comparison             20           39.2
---
---       =                      9           17.6
---       /=                     4            7.8
---       >                      1            2.0
---       <                      3            5.9
---       >=                     1            2.0
---       <=                     2            3.9
---
---    Logic                   4            7.8
---
---       AND                    1            2.0
---       OR                     1            2.0
---       NOT                    2            3.9
---
---                           --          -----
---                           51           99.9
---
---
---  3. Operand Type (counted once per operand reference)
---  ---------------
---                          number    approximate
---                                    percentage
---
---     Integer               135        55.1 %
---     Character              47        19.2 %
---     Enumeration            30        12.2 %
---     Boolean                11         4.5 %
---     Pointer                12         5.0 %
---     String30                6         2.4 %
---     Array                   2         0.8 %
---     Record                  2         0.8 %
---                           ---       -------
---                           245       100.0 %
---
---  When there is an access path leading to the final operand (e.g. a record
---  component), only the final data type on the access path is counted.
---
---  There are 16 accesses to components of a record, 9 of them go to
---  a component in a variant part. For some of these accesses, the
---  compiler may suppress generation of code checking the tag field
---  during optimization.
---
---
---  3. Operand Locality:
---  -------------------
---
---     local variable              120        49.0 %
---     global variable              20         8.2 %
---        same package                 19          7.8 %
---        other package                 1          0.4 %
---     parameter                    45        18.3 %
---        in                           27         11.0 %
---        inout                        12          5.0 %
---        out                           6          2.4 %
---     function result               5         2.0 %
---     constant                     55        22.4 %
---                                 ---       -------
---                                 245        99.9 %
---
---
---  There may be cases where a highly optimizing compiler may recognize
---  unnecessary statements and may not generate code for them.
---
---  There has been no explicit effort to account for the effects of a
---  cache, or to balance the use of long or short displacements for code or
---  data.
---
---  The program does not compute anything meaningful, but it is syntactically
---  and semantically correct. All variables have a value assigned to them
---  before they are used as a source operand.
---
---------------------------------------------------------------------------------
-
-package Global_Def is
-------------------
-
-  -- Global type definitions
-
-  type Enumeration is (Ident_1, Ident_2, Ident_3, Ident_4, Ident_5);
-
-  subtype One_To_Thirty is integer range 1..30;
-  subtype One_To_Fifty is integer range 1..50;
-  subtype Capital_Letter is character range 'A'..'Z';
-
-  type String_30 is array (One_To_Thirty) of character;
-    pragma Pack (String_30);
-    -- This pragma may be omitted if it leads to a packing of a character
-    -  in less than an 8-bit byte.
-
-  type Array_1_Dim_Integer is array (One_To_Fifty) of integer;
-  type Array_2_Dim_Integer is array (One_To_Fifty,
-                                     One_To_Fifty) of integer;
-
-  type Record_Type (Discr: Enumeration := Ident_1);
-  type Record_Pointer is access Record_Type;
-
-  type Record_Type (Discr: Enumeration := Ident_1) is
-               record
-                Pointer_Comp:   Record_Pointer;
-                case Discr is
-                  when Ident_1 =>     -- only this variant is used,
-                                      -- but in some cases discriminant
-                                      -- checks are necessary
-                    Enum_Comp:      Enumeration;
-                    Int_Comp:       One_To_Fifty;
-                    String_Comp:    String_30;
-                  when Ident_2 =>
-                    Enum_Comp_2:    Enumeration;
-                    String_Comp_2:  String_30;
-                  when others =>
-                    Char_Comp_1,
-                    Char_Comp_2:    character;
-                end case;
-              end record;
-
-end Global_Def;
//GO.SYSIN DD d_global.s
echo d_main.b 1>&2
sed >d_main.b <<'//GO.SYSIN DD d_main.b' 's/^-//'
-------------------------------------------------------------------------
---
---                   "DHRYSTONE" Benchmark Program
---                   -----------------------------
---                                                                            
---  Version:    Ada, Version 2.1
---                                                                            
---  File:       d_main.b (part 6 of 6)
---
---  Date:       August 17, 1988
---
---  Author:     Reinhold P. Weicker
---
-------------------------------------------------------------------------
-
-  with Global_Def, Pack_1;
-  use Global_Def;
-
-procedure Main is
---------------
-
-begin
-
-  Pack_1.Proc_0;   -- Proc_0 is actually the main program, but it is part
-                   -- of a package, and a program within a package can
-                   -- not be designated as the main program for execution.
-                   -- Therefore Proc_0 is activated by a call from "Main".
-
-end Main;
-
//GO.SYSIN DD d_main.b
echo d_pack_1.b 1>&2
sed >d_pack_1.b <<'//GO.SYSIN DD d_pack_1.b' 's/^-//'
-------------------------------------------------------------------------
---
---                   "DHRYSTONE" Benchmark Program
---                   -----------------------------
---                                                                            
---  Version:    Ada, Version 2.1
---		(Portable Version)
---                                                                            
---  File:       d_pack_1.b (part 4 of 6)
---
---  Date:       December 17, 1988
---
---  Author:     Reinhold P. Weicker
---
---  Comments:	This package contains, along with other procedures,
---		Proc_0 which encloses the measurement loop
---		and the statements printing the results.
---
---		For execution time measurement, a call to the procedure
---		"Clock" of package CALENDAR is used.
---		Note that Clock returns the elapsed time
---		(wall clock time). When more processes than Dhrystone
---		are running, the time values returned by the procedures
---		of CALENDAR do NOT represent the (process-specific)
---		execution time of Dhrystone.
---		
---		For more accurate time measurement, replace the calls to
---		Clock by calls to (implementation-specific)
---		procedures that return the process-specific time.
---		However, no such procedures are defined in Standard Ada.
---
---		Timing issues for Ada are discussed in "Toward Real-Time
---		Performance Benchmarks for Ada" (Russell M. Clapp et al.,
---		CACM vol. 29, no. 8, August 1986, pp. 760-778).
---
-------------------------------------------------------------------------
-
-with	Global_Def, Pack_2, TEXT_IO, CALENDAR;
-pragma  ELABORATE (TEXT_IO);
-use	Global_Def, TEXT_IO;
-
-package body Pack_1 is
--------------------
-
-  package INT_IO is new TEXT_IO.INTEGER_IO (Integer);
-  package FLOAT_IO is new TEXT_IO.FLOAT_IO (Float);
-  package ENUM_IO is new TEXT_IO.ENUMERATION_IO (Enumeration);
-  package BOOL_IO is new TEXT_IO.ENUMERATION_IO (Boolean);
-  use     INT_IO, FLOAT_IO, ENUM_IO, BOOL_IO;
-
-
-  Bool_Glob:         boolean;
-  Char_Glob_2:       character;
-  Array_Glob_1:      Array_1_Dim_Integer;
-  Array_Glob_2:      Array_2_Dim_Integer;
-  Pointer_Glob,
-  Pointer_Glob_Next: Record_Pointer;
-
-  procedure Proc_4;
-  procedure Proc_5;
-
-  -- for measurement:
-  Too_Small_Time:	constant := 2.0;
-	-- Measurements should last at least 2 seconds
-  Max_Number_Of_Runs:	constant := 1_000_000;
-  subtype Run_Range is integer range 1 .. Max_Number_Of_Runs;
-
-procedure Proc_0
-is
-  Int_Loc_1,
-  Int_Loc_2,
-  Int_Loc_3:     One_To_Fifty;
-  Char_Loc:      character;
-  Enum_Loc:      Enumeration;
-  String_Loc_1,
-  String_Loc_2:  String_30;
-
-  -- Variables for time measurement:
-  Run_Index,
-  Number_Of_Runs:	Run_Range;
-  Begin_Time,
-  End_Time:		Calendar.Time;
-  Run_Time:		Duration;
-  Microseconds,
-  Dhry_Per_Sec:		float;
-
-begin
-
-  -- Initializations
-
-  Pack_1.Pointer_Glob_Next := new Record_Type;
-
-  Pack_1.Pointer_Glob := new Record_Type
-                        '(
-                          Pointer_Comp   => Pack_1.Pointer_Glob_Next,
-                          Discr          => Ident_1,
-                          Enum_Comp      => Ident_3,
-                          Int_Comp       => 40,
-                          String_Comp    => "DHRYSTONE PROGRAM, SOME STRING"
-                         );
-
-  String_Loc_1 := "DHRYSTONE PROGRAM, 1'ST STRING";
-
-  Array_Glob_2 (8,7) := 10;
-
-  Put_Line ("Dhrystone Benchmark, Version 2.1 (Language: Ada)");
-  New_Line;
-  Put_Line ("Please give the number of runs through the benchmark: ");
-  Put ("> ");
-  Get (Number_Of_Runs);
-
-  Put ("Execution starts, ");
-  Put (Number_Of_Runs);
-  Put ("  runs through Dhrystone");
-  New_Line;
-  
-  -----------------
-  -- Start timer --
-  -----------------
-
-  Begin_Time := Calendar.Clock;
-
-  for Run_Index in 1 .. Number_Of_Runs Loop
-
-    Proc_5;
-    Proc_4;
-      -- Char_Glob_ 'A', Char_Glob_2 = 'B', Bool_Glob = false
-    Int_Loc_1 := 2;
-    Int_Loc_2 := 3;
-    String_Loc_2 := "DHRYSTONE PROGRAM, 2'ND STRING";
-    Enum_Loc := Ident_2;
-    Bool_Glob := not Pack_2.Func_2 (String_Loc_1, String_Loc_2);
-      -- Bool_Glob = true
-    while Int_Loc_1 < Int_Loc_2 loop  -- loop body executed once
-      Int_Loc_3 := 5 * Int_Loc_1 - Int_Loc_2;
-        -- Int_Loc_3 = 7
-      Pack_2.Proc_7 (Int_Loc_1, Int_Loc_2, Int_Loc_3);
-        -- Int_Loc_3 = 7
-      Int_Loc_1 := Int_Loc_1 + 1;
-    end loop;
-        -- Int_Loc_1 = 3
-    Pack_2.Proc_8 (Array_Glob_1, Array_Glob_2, Int_Loc_1, Int_Loc_3);
-      -- Int_Glob = 5
-    Proc_1 (Pointer_Glob);
-    for Char_Index in 'A' .. Char_Glob_2 loop -- loop body executed twice
-      if Enum_Loc = Pack_2.Func_1 (Char_Index, 'C')
-      then -- not executed
-        Pack_2.Proc_6 (Ident_1, Enum_Loc);
-        String_Loc_2 := "DHRYSTONE PROGRAM, 3'RD STRING";
-        Int_Loc_2 := Run_Index;
-        Int_Glob := Run_Index;
-      end if;
-    end loop;
-      -- Enum_Loc = Ident_1
-      -- Int_Loc_1 = 3, Int_Loc_2 = 3, Int_Loc_3 = 7
-    Int_Loc_2 := Int_Loc_2 * Int_Loc_1;
-    Int_Loc_1 := Int_Loc_2 / Int_Loc_3;
-    Int_Loc_2 := 7 * (Int_Loc_2 - Int_Loc_3) - Int_Loc_1;
-      -- Int_Loc_1 = 1, Int_Loc_2 = 13, Int_Loc_3 = 7
-    Proc_2 (Int_Loc_1);
-      -- Int_Loc_1 = 5
-
-  end loop; -- for Run_Index
-
-  ----------------
-  -- Stop timer --
-  ----------------
-
-  End_Time := Calendar.Clock;
-
-  Put_Line ("Execution ends");
-  New_Line;
-  Put_Line ("Final values of the variables used in the benchmark:");
-  New_Line;
-
-  INT_IO.DEFAULT_WIDTH := 6;
-  Put      ("Int_Glob:          ");
-  Put (Int_Glob);
-  New_Line; 
-  Put_Line ("        should be:      5");
-  Put      ("Bool_Glob:           ");
-  Put (Bool_Glob);
-  New_Line;
-  Put_Line ("        should be:   TRUE");
-  Put      ("Char_Glob_1:         ");
-  Put (Char_Glob_1);
-  New_Line;
-  Put_Line ("        should be:   A");
-  Put      ("Char_Glob_2:         ");
-  Put (Char_Glob_2);
-  New_Line;
-  Put_Line ("        should be:   B");
-  Put      ("Array_Glob_1 (8):  ");
-  Put (Array_Glob_1 (8));
-  New_Line;
-  Put_Line ("        should be:      7");
-  Put      ("Array_Glob_2 (8,7): ");
-  Put (Array_Glob_2 (8,7));
-  New_Line;
-  Put_Line ("        should be:   Number_Of_Runs + 10");
-  Put_Line ("Pointer_Glob.");
-  Put_Line ("  Pointer_Comp:      (implementation-dependent)");
-  Put      ("  Discr:             ");
-  Put (Pointer_Glob.Discr);
-  New_Line;
-  Put_Line ("        should be:   IDENT_1");
-  Put      ("  Enum_Comp:         ");
-  Put (Pointer_Glob.Enum_Comp);
-  New_Line;
-  Put_Line ("     should be:      IDENT_3");
-  Put      ("  Int_Comp:        ");
-  Put (Pointer_Glob.Int_Comp);
-  New_Line;
-  Put_Line ("     should be:        17");
-  Put      ("  String_Comp:       ");
-  for I in 1 .. 30 loop
-    Put (Pointer_Glob.String_Comp (I));
-  end loop;
-  New_Line;
-  Put_Line ("     should be:      DHRYSTONE PROGRAM, SOME STRING");
-  Put_Line ("Pointer_Glob_Next.");
-  Put_Line ("  Pointer_Comp:      (implementation-dependent)");
-  Put      ("  Discr:             ");
-  Put (Pointer_Glob_Next.Discr);
-  New_Line;
-  Put_Line ("        should be:   IDENT_1");
-  Put      ("  Enum_Comp:         ");
-  Put (Pointer_Glob_Next.Enum_Comp);
-  New_Line;
-  Put_Line ("     should be:      IDENT_2");
-  Put      ("  Int_Comp:        ");
-  Put (Pointer_Glob_Next.Int_Comp);
-  New_Line;
-  Put_Line ("     should be:        18");
-  Put      ("  String_Comp:       ");
-  for I in 1 .. 30 loop
-    Put (Pointer_Glob_Next.String_Comp (I));
-  end loop;
-  New_Line;
-  Put_Line ("     should be:      DHRYSTONE PROGRAM, SOME STRING");
-  Put      ("Int_Loc_1:         ");
-  Put (Int_Loc_1);
-  New_Line;
-  Put_Line ("        should be:      5");
-  Put      ("Int_Loc_2:         ");
-  Put (Int_Loc_2);
-  New_Line;
-  Put_Line ("        should be:     13");
-  Put      ("Int_Loc_3:         ");
-  Put (Int_Loc_3);
-  New_Line;
-  Put_Line ("        should be:      7");
-  Put      ("Enum_Loc:            ");
-  Put (Enum_Loc);
-  New_Line;
-  Put_Line ("     should be:      IDENT_2");
-  Put      ("String_Loc_1         ");
-  for I in 1 .. 30 loop
-    Put (String_Loc_1 (I));
-  end loop;
-  New_Line;
-  Put_Line ("     should be:      DHRYSTONE PROGRAM, 1'ST STRING");
-  Put      ("String_Loc_2         ");
-  for I in 1 .. 30 loop
-    Put (String_Loc_2 (I));
-  end loop;
-  New_Line;
-  Put_Line ("     should be:      DHRYSTONE PROGRAM, 2'ND STRING");
-  New_Line;
- 
-  -- Compute Execution Time
-
-  Run_Time :=  Calendar."-" (End_Time, Begin_Time);
-  if Run_Time < Too_Small_Time
-  then
-    Put_Line ("Measured Time too small to obtain meaningful results");
-    Put_Line ("Please increase number of runs");
-  else
-    Microseconds := 1_000_000.0 * float (Run_Time) / float (Number_Of_Runs);
-    Dhry_Per_Sec := float (Number_of_Runs) / float (Run_Time);
-    Put ("Microseconds for one run through Dhrystone:  ");
-    Put (Microseconds, Aft => 2, Exp => 0);
-    New_Line;
-    Put ("Dhrystones per second:                       ");
-    Put (Dhry_Per_Sec, Aft => 2, Exp => 0);
-    New_Line;
-  end if;
-  New_Line;
-
-end Proc_0;
-
-procedure Proc_1 (Pointer_Par_In: in Record_Pointer)
-is  -- executed once
-  Next_Record: Record_Type
-    renames Pointer_Par_In.Pointer_Comp.all; -- = Pointer_Glob_Next.all
-begin
-  Next_Record := Pointer_Glob.all;
-  Pointer_Par_In.Int_Comp := 5;
-  Next_Record.Int_Comp := Pointer_Par_In.Int_Comp;
-  Next_Record.Pointer_Comp := Pointer_Par_In.Pointer_Comp;
-  Proc_3 (Next_Record.Pointer_Comp);
-    -- Next_Record.Pointer_Comp = Pointer_Glob.Pointer_Comp = Pointer_Glob_Next
-  if Next_Record.Discr = Ident_1
-  then -- executed
-    Next_Record.Int_Comp := 6;
-    Pack_2.Proc_6 (Pointer_Par_In.Enum_Comp, Next_Record.Enum_Comp);
-    Next_Record.Pointer_Comp := Pointer_Glob.Pointer_Comp;
-    Pack_2.Proc_7 (Next_Record.Int_Comp, 10, Next_Record.Int_Comp);
-  else -- not executed
-    Pointer_Par_In.all := Next_Record;
-  end if;
-end Proc_1;
-
-procedure Proc_2 (Int_Par_In_Out: in out One_To_Fifty)
-is  -- executed once
-    -- In_Par_In_Out = 3, becomes 7
-  Int_Loc:  One_To_Fifty;
-  Enum_Loc: Enumeration;
-begin
-  Int_Loc := Int_Par_In_Out + 10;
-  loop -- executed once
-    if Char_Glob_1 = 'A'
-    then -- executed
-      Int_Loc := Int_Loc - 1;
-      Int_Par_In_Out := Int_Loc - Int_Glob;
-      Enum_Loc := Ident_1;
-    end if;
-  exit when Enum_Loc = Ident_1; -- true
-  end loop;
-end Proc_2;
-
-procedure Proc_3 (Pointer_Par_Out: out Record_Pointer)
-is  -- executed once
-    -- Pointer_Par_Out becomes Pointer_Glob
-begin
-  if Pointer_Glob /= null
-  then -- executed
-    Pointer_Par_Out := Pointer_Glob.Pointer_Comp;
-  end if;
-  Pack_2.Proc_7 (10, Int_Glob, Pointer_Glob.Int_Comp);
-end Proc_3;
-
-procedure Proc_4 -- without parameters
-is  -- executed once
-  Bool_Loc: boolean;
-begin
-  Bool_Loc := Char_Glob_1 = 'A';
-  Bool_Glob := Bool_Loc or Bool_Glob;
-  Char_Glob_2 := 'B';
-end Proc_4;
-
-procedure Proc_5 -- without parameters
-is  -- executed once
-begin
-  Char_Glob_1 := 'A';
-  Bool_Glob := false;
-end Proc_5;
-
-end Pack_1;
-
-
//GO.SYSIN DD d_pack_1.b
echo d_pack_1.s 1>&2
sed >d_pack_1.s <<'//GO.SYSIN DD d_pack_1.s' 's/^-//'
-------------------------------------------------------------------------
---
---                   "DHRYSTONE" Benchmark Program
---                   -----------------------------
---                                                                            
---  Version:    Ada, Version 2.1
---                                                                            
---  File:       d_pack_1.s (part 2 of 6)
---
---  Date:       August 17, 1988
---
---  Author:     Reinhold P. Weicker
---
-------------------------------------------------------------------------
-
-  with Global_Def;
-  use Global_Def;
-
-package Pack_1 is
---------------
-
-  procedure Proc_0;
-  procedure Proc_1 (Pointer_Par_In:     in     Record_Pointer);
-  procedure Proc_2 (Int_Par_In_Out:     in out One_To_Fifty);
-  procedure Proc_3 (Pointer_Par_Out:    out    Record_Pointer);
-
-  Int_Glob:          integer;
-  Char_Glob_1:       character;
-
-end Pack_1;
-
-
//GO.SYSIN DD d_pack_1.s
echo d_pack_2.b 1>&2
sed >d_pack_2.b <<'//GO.SYSIN DD d_pack_2.b' 's/^-//'
-------------------------------------------------------------------------
---
---                   "DHRYSTONE" Benchmark Program
---                   -----------------------------
---                                                                            
---  Version:    Ada, Version 2.1
---                                                                            
---  File:       d_pack_2.b (part 5 of 6)
---
---  Date:       August 17, 1988
---
---  Author:     Reinhold P. Weicker
---
-------------------------------------------------------------------------
-
-with Global_Def, Pack_1;
-use Global_Def;
-
-package body Pack_2 is
--------------------
-
-function Func_3 (Enum_Par_In: in Enumeration) return boolean;
-         -- forward declaration
-
-procedure Proc_6 (Enum_Par_In:  in  Enumeration;
-                  Enum_Par_Out: out Enumeration)
-is  -- executed once
-    -- Enum_Par_In = Ident_3, Enum_Par_Out becomes Ident_2
-begin
-  Enum_Par_Out := Enum_Par_In;
-  if not Func_3 (Enum_Par_In)
-  then -- not executed
-    Enum_Par_Out := Ident_4;
-  end if;
-  case Enum_Par_In is
-    when Ident_1 => Enum_Par_Out := Ident_1;
-    when Ident_2 => if Pack_1.Int_Glob > 100
-                      then Enum_Par_Out := Ident_1;
-                      else Enum_Par_Out := Ident_4;
-                    end if;
-    when Ident_3 => Enum_Par_Out := Ident_2;    -- executed
-    when Ident_4 => null;
-    when Ident_5 => Enum_Par_Out := Ident_3;
-  end case;
-end Proc_6;
-
-procedure Proc_7 (Int_Par_In_1,
-                  Int_Par_In_2:   in  One_To_Fifty;
-                  Int_Par_Out:    out One_To_Fifty)
-is  -- executed three times
-    -- first call:      Int_Par_In_1 = 2, Int_Par_In_2 = 3,
-    --                  Int_Par_Out becomes 7
-    -- second call:     Int_Par_In_1 = 6, Int_Par_In_2 = 10,
-    --                  Int_Par_Out becomes 18
-    -- third call:      Int_Par_In_1 = 10, Int_Par_In_2 = 5,
-    --                  Int_Par_Out becomes 17
-  Int_Loc: One_To_Fifty;
-begin
-  Int_Loc := Int_Par_In_1 + 2;
-  Int_Par_Out := Int_Par_In_2 + Int_Loc;
-end Proc_7;
-
-procedure Proc_8 (Array_Par_In_Out_1: in out Array_1_Dim_Integer;
-                  Array_Par_In_Out_2: in out Array_2_Dim_Integer;
-                  Int_Par_In_1,
-                  Int_Par_In_2:       in     integer)
-is  -- executed once
-    -- Int_Par_In_1 = 3
-    -- Int_Par_In_2 = 7
-  Int_Loc: One_To_Fifty;
-begin
-  Int_Loc := Int_Par_In_1 + 5;
-  Array_Par_In_Out_1 (Int_Loc) := Int_Par_In_2;
-  Array_Par_In_Out_1 (Int_Loc+1) :=
-                          Array_Par_In_Out_1 (Int_Loc);
-  Array_Par_In_Out_1 (Int_Loc+30) := Int_Loc;
-  for Int_Index in Int_Loc .. Int_Loc+1 loop -- loop body executed twice
-    Array_Par_In_Out_2 (Int_Loc, Int_Index) := Int_Loc;
-  end loop;
-  Array_Par_In_Out_2 (Int_Loc, Int_Loc-1) :=
-                          Array_Par_In_Out_2 (Int_Loc, Int_Loc-1) + 1;
-  Array_Par_In_Out_2 (Int_Loc+20, Int_Loc) :=
-                          Array_Par_In_Out_1 (Int_Loc);
-  Pack_1.Int_Glob := 5;
-end Proc_8;
-
-function Func_1 (Char_Par_In_1,
-                 Char_Par_In_2: in Capital_Letter)
-                                                return Enumeration
-is  -- executed three times, returns Ident_1 each time
-    -- first call:      Char_Par_In_1 = 'H', Char_Par_In_2 = 'R'
-    -- second call:     Char_Par_In_1 = 'A', Char_Par_In_2 = 'C'
-    -- third call:      Char_Par_In_1 = 'B', Char_Par_In_2 = 'C'
-  Char_Loc_1, Char_Loc_2: Capital_Letter;
-begin
-  Char_Loc_1 := Char_Par_In_1;
-  Char_Loc_2 := Char_Loc_1;
-  if Char_Loc_2 /= Char_Par_In_2
-  then  -- executed
-    return Ident_1;
-  else  -- not executed
-    Pack_1.Char_Glob_1 := Char_Loc_1;
-    return Ident_2;
-  end if;
-  end Func_1;
-
-function Func_2 (String_Par_In_1,
-                 String_Par_In_2: in String_30) return boolean
-is  -- executed once, returns false
-    -- String_Par_In_1 = "DHRYSTONE PROGRAM, 1'ST STRING"
-    -- String_Par_In_2 = "DHRYSTONE PROGRAM, 2'ND STRING"
-  Int_Loc:  One_To_Thirty;
-  Char_Loc: Capital_Letter;
-begin
-  Int_Loc := 2;
-  while Int_Loc <= 2 loop -- loop body executed once
-    if Func_1 (String_Par_In_1(Int_Loc),
-               String_Par_In_2(Int_Loc+1)) = Ident_1
-    then -- executed
-      Char_Loc := 'A';
-      Int_Loc := Int_Loc + 1;
-    end if;
-  end loop;
-  if Char_Loc >= 'W' and Char_Loc < 'Z'
-  then -- not executed
-    Int_Loc := 7;
-  end if;
-  if Char_Loc = 'R'
-  then -- not executed
-    return true;
-  else -- executed
-    if String_Par_In_1 = String_Par_In_2
-    -- if String_Par_In_1 > String_Par_In_2
-    -- not yet implemented
-    then -- not executed
-      Int_Loc := Int_Loc + 7;
-      Pack_1.Int_Glob := Int_Loc;
-      return true;
-    else -- executed
-      return false;
-    end if;
-  end if;
-end Func_2;
-
-function Func_3 (Enum_Par_In: in Enumeration) return boolean
-is  -- executed once, returns true
-    -- Enum_Par_In = Ident_3
-  Enum_Loc:  Enumeration;
-begin
-  Enum_Loc := Enum_Par_In;
-  if Enum_Loc = Ident_3
-  then -- executed
-    return true;
-  else -- not executed
-    return false;
-  end if;
-end Func_3;
-
-end Pack_2;
//GO.SYSIN DD d_pack_2.b
echo d_pack_2.s 1>&2
sed >d_pack_2.s <<'//GO.SYSIN DD d_pack_2.s' 's/^-//'
-------------------------------------------------------------------------
---
---                   "DHRYSTONE" Benchmark Program
---                   -----------------------------
---                                                                            
---  Version:    Ada, Version 2.1
---                                                                            
---  File:       d_pack_2.s (part 3 of 6)
---
---  Date:       August 17, 1988
---
---  Author:     Reinhold P. Weicker
---
-------------------------------------------------------------------------
-
-  with Global_Def;
-  use Global_Def;
-
-package Pack_2 is
---------------
-
-  procedure Proc_6 (Enum_Par_In:        in     Enumeration;
-                    Enum_Par_Out:       out    Enumeration);
-  procedure Proc_7 (Int_Par_In_1,
-                    Int_Par_In_2:       in     One_To_Fifty;
-                    Int_Par_Out:        out    One_To_Fifty);
-  procedure Proc_8 (Array_Par_In_Out_1: in out Array_1_Dim_Integer;
-                    Array_Par_In_Out_2: in out Array_2_Dim_Integer;
-                    Int_Par_In_1,
-                    Int_Par_In_2:       in     integer);
-  function Func_1 (Char_Par_In_1,
-                   Char_Par_In_2:       in     Capital_Letter)
-                                                    return Enumeration;
-  function Func_2 (String_Par_In_1,
-                   String_Par_In_2:     in     String_30)
-                                                    return boolean;
-
-end Pack_2;
-
-
//GO.SYSIN DD d_pack_2.s
echo dhry_c.dif 1>&2
sed >dhry_c.dif <<'//GO.SYSIN DD dhry_c.dif' 's/^-//'
-7c7
-<  *  Version:    C, Version 2.1
----
->  *  Version:    C, Version 2.0
-11c11
-<  *  Date:       May 17, 1988
----
->  *  Date:       March 3, 1988
-50,51d49
-< #define Too_Small_Time 120
-<                 /* Measurements should last at least about 2 seconds */
-55a54,58
-> #endif
-> #ifdef MSC_TIME
-> clock_t	clock();
-> #endif
-> 
-58d60
-< #endif
-73a76
-> 
-84a88
-> 
-99,100c103,105
-<         /* Was missing in published program. Without this statement,    */
-<         /* Arr_2_Glob [8][7] would have an undefined value.             */
----
->         /* Was missing in published program. Without this               */
->         /* initialization, Arr_2_Glob [8][7] would have an              */
->         /* undefined value.                                             */
-105c110
-<   printf ("Dhrystone Benchmark, Version 2.1 (Language: C)\n");
----
->   printf ("Dhrystone Benchmark, Version 2.0 (Language: C)\n");
-134a140,142
-> #ifdef MSC_CLOCK
->   Begin_Time = clock();
-> #endif
-192a201,203
-> #ifdef MSC_CLOCK
->   End_Time = clock();
-> #endif
-281c292
-< /******************/
----
-> /**********************/
-338c349
-< /******************/
----
-> /**********************/
-347a359,360
->   else /* not executed */
->     Int_Glob = 100;
-351a365
-> 
-384,385d397
-< 
-< 
//GO.SYSIN DD dhry_c.dif
echo submit.frm 1>&2
sed >submit.frm <<'//GO.SYSIN DD submit.frm' 's/^-//'
-DHRYSTONE 2.1 BENCHMARK REPORTING FORM
-MANUF:
-MODEL:
-PROC:
-CLOCK:
-OS:
-OVERSION:
-COMPILER:
-CVERSION:
-OPTIONS:
-NOREG:
-REG:
-NOTES:
-DATE:
-SUBMITTER:
-CODESIZE:
-MAILTO: uunet!pcrat!dry2
//GO.SYSIN DD submit.frm
